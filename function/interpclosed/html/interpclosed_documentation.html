
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>interpclosed documentation</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-17"><meta name="DC.source" content="interpclosed_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>interpclosed</tt> documentation</h1><!--introduction--><p>The <tt>interpclosed</tt> function creates piecewise polynomial fits of 2D closed curves given by a set of points. The function can be used to (i) return the fit itself; (ii) interpolate values within the curve using an arc-length parametrization; or (iii) return the area, perimeter and centroid of the curve. <tt>interpclosed</tt> was inspired largely by the functions <tt>cscvn</tt>, <tt>interparc</tt> and <tt>arclength</tt>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Examples</a></li><li><a href="#21">See also</a></li><li><a href="#22">About</a></li></ul></div><h2 id="1">Syntax</h2><p><tt>xyq = interpclosed(x,y,tq)</tt></p><p><tt>[len,area] = interpclosed(x,y)</tt></p><p><tt>[len,area,c] = interpclosed(x,y)</tt></p><p><tt>[len,area,c,I] = interpclosed(x,y)</tt></p><p><tt>pp = interpclosed(x,y,'pp')</tt></p><p><tt>[xyq,len,area] = interpclosed(x,y,tq)</tt></p><p><tt>[xyq,len,area,c] = interpclosed(x,y,tq)</tt></p><p><tt>[xyq,len,area,c,I] = interpclosed(x,y,tq)</tt></p><p><tt>[___] = interpclosed(_,method)</tt></p><p><tt>[___] = interpclosed(_,print)</tt></p><h2 id="2">Description</h2><p><tt>xyq = interpclosed(x,y,tq)</tt> interpolates new data points <tt>xyq</tt> at given positions defined by the array <tt>tq</tt>, along the closed curve defined by the points specified by <tt>x</tt> and <tt>y</tt>. <tt>xyq</tt> is a 2-by-n array containing the x-y points corresponding to the query parameter positions defined in the n-by-1 array <tt>tq</tt>. The elements of <tt>tq</tt> can only take values between <img src="interpclosed_documentation_eq05816708510759450028.png" alt="$[0,1]$" style="width:26px;height:15px;">, with 0 being the first point of the curve, 1 the last one and 0.5, for example, being in the middle of the length of the curve. The default method <tt>'spline'</tt> is used.</p><p><tt>[len,area] = interpclosed(x,y)</tt> returns the perimeter <tt>len</tt> and area <tt>area</tt> of the interpolated curve.</p><p><tt>[len,area,c] = interpclosed(x,y)</tt> returns the perimeter, the area and the centroid <tt>c</tt> of the interpolated curve.</p><p><tt>[len,area,c,I] = interpclosed(x,y)</tt> returns the perimeter, the area, the centroid <tt>c</tt>, and second moments of area <tt>I</tt> of the interpolated curve.</p><p><tt>pp = interpclosed(x,y,'pp')</tt> returns the piece-wise polynomial <tt>pp</tt>, which is a parametrization of the fit of <tt>x</tt> and <tt>y</tt> in the form <img src="interpclosed_documentation_eq14833433867325483769.png" alt="$x(t)$" style="width:24px;height:15px;"> and <img src="interpclosed_documentation_eq10822186844117743572.png" alt="$y(t)$" style="width:23px;height:15px;">.</p><p><tt>[xyq,len,area] = interpclosed(x,y,tq)</tt> returns the new data points and the perimeter and area.</p><p><tt>[xyq,len,area,c] = interpclosed(x,y,tq)</tt> returns the new data points and the perimeter, area, and centroid.</p><p><tt>[xyq,len,area,c,I] = interpclosed(x,y,tq)</tt> returns the new data points and the perimeter, area, centroid and second moments of area.</p><p><tt>[___] = interpclosed(_,method)</tt> specifies the string <tt>method</tt>: <tt>'linear'</tt>, <tt>'spline'</tt>, or <tt>'pchip'</tt>. The default method is <tt>'spline'</tt>.</p><p><tt>[___] = interpclosed(_,print)</tt> additionaly prints some figures to show the results. For printing 64 equally arc-length spaced points are used.</p><h2 id="3">Examples</h2><p><b>The Interpolated Batman</b></p><p>This first example only serves as a way to show off the power of the function, for more specific application examples, see the ones below.</p><p>The so-called Batman function is a somewhat complex piecewise function. To construct it, 6 functions have to be defined between certain values of <img src="interpclosed_documentation_eq12428413953531653171.png" alt="$x$" style="width:8px;height:7px;"> and <img src="interpclosed_documentation_eq08830444604280721118.png" alt="$y$" style="width:7px;height:10px;">. You can find more information about the Batman function <a href="https://de.mathworks.com/matlabcentral/answers/13131-batman-equation-in-matlab">here</a> and <a href="https://de.mathworks.com/matlabcentral/fileexchange/33124-batman-equation-the-legend">here</a>.</p><p>We, on the other hand, will create it as a piecewise polynomial function that delivers very good results, out of a bunch of carefully selected points.</p><p>First, we have to define the dataset and plot it to see what it looks like. Since the Batman function is symmetric around the y-axis, we just need the half of the actual points, then we can flip the arrays and append them conveniently. A minimum set of points was selected by choosing only the points defining vertices, and, when a curve was necessary, just one middle-point.</p><pre class="codeinput">x = [0 0.5 0.5 0.75 0.75 1 1 2 3 3 7 4 4 3 2 2 1 0];

y = [2.25 2.25 2.25 3 3 1 1 0.863142928 2.717392773 2.717392773 <span class="keyword">...</span>
    0 -2.46195542 -2.46195542 -1.32235 -2.365485004 -2.365485004 <span class="keyword">...</span>
    -1.59137226 -3];

x = [x, -fliplr(x)]; y = [y,fliplr(y)];

figure, plot(x,y,<span class="string">'o'</span>), axis <span class="string">equal</span>
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_01.png" alt=""> <p>This doesn't look as terrifying as the dark knight, but we will fix this in a bit. Please note that some points are given twice, this is done to indicate that the 1st derivative at those points does not have to be continuous. This idea was taken from the function <tt>cscvn</tt> and was extended to the pchip fit here. For more information, go <a href="https://de.mathworks.com/help/curvefit/cscvn.html">here</a>.</p><p>Then fit and plot 300 equally spaced interpolation points, quite awesomely.</p><pre class="codeinput">n = 300;
xyq = interpclosed(x,y,0:1/n:1);
figure, fill(xyq(1,:),xyq(2,:),<span class="string">'k'</span>), hold <span class="string">on</span>
plot(x,y,<span class="string">'yo'</span>,<span class="string">'MarkerFaceColor'</span>,[1 .93 .22]), axis <span class="string">equal</span>, grid <span class="string">on</span>
legend(<span class="string">'Batman'</span>,<span class="string">'Original points'</span>)
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_02.png" alt=""> <p>The result is pretty legendary and was only created with 12 distinct points and knowledge about the continuity of the derivatives at those points. The bat-signal's orientation in 2D space is quite obvious to detect, this is down to the fact that its principal axes are easy to find. For instance, the signal has symmetry around the y-axis. This makes this particular shape useful to show the calculations that produce the geometric moments: area, centroid and second moment of area. The task will be to identify both a random rotation and translation of the shape. Let's make a figure with four subplots and assign an equal number of rotation and translations. Then compute the area, centroid, and second moment of area. This last piece of information will give us the information about the roration.</p><pre class="codeinput"><span class="comment">% Define the rotations and translations</span>
rot = 2*pi*rand(1,4);
dx = (-50+100*rand(1,4));
dy = (-50+100*rand(1,4));
<span class="comment">% Create the figure</span>
figure
<span class="keyword">for</span> ii = 1:4
    <span class="comment">% Compile the x and y vectors into a matrix</span>
    xy = [x;y];
    <span class="comment">% Rotate around (0,0)</span>
    R = [cos(rot(ii)) -sin(rot(ii)); sin(rot(ii)) cos(rot(ii))];
    xy = R*xy;
    <span class="comment">% Translate</span>
    xn = xy(1,:)+dx(ii);
    yn = xy(2,:)+dy(ii);
    <span class="comment">% Interpolate and find the area, centroid and second moments of area</span>
    [xyq,~,area,c,I] = interpclosed(xn,yn,0:1/n:1);
    <span class="comment">% Create the subplot</span>
    subplot(2,2,ii), hold <span class="string">on</span>
    <span class="comment">% Show the bat-signal</span>
    fill(xyq(1,:),xyq(2,:),<span class="string">'k'</span>), hold <span class="string">on</span>
    <span class="comment">% Create the x- and y-axes before rotation</span>
    xaxis = [-1,1;0,0]*5.25;
    yaxis = [0,0;-1,1]*7;
    <span class="comment">% Use the second moments of area to find the rotation</span>
    theta = -atan2(2*(I(3)-area*c(1)*c(2)),<span class="keyword">...</span>
        ((I(1)-area*c(2)^2)-(I(2)-area*c(1)^2)))/2;
    <span class="comment">% Construct the rotation matrix again</span>
    R = [cos(theta) -sin(theta); sin(theta) cos(theta)];
    <span class="comment">% Rotate the axes</span>
    xaxis = R*xaxis;
    yaxis = R*yaxis;
    <span class="comment">% Plot the axes</span>
    plot(xaxis(1,:)+c(1),xaxis(2,:)+c(2),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,1)
    plot(yaxis(1,:)+c(1),yaxis(2,:)+c(2),<span class="string">'r--'</span>)
    axis <span class="string">equal</span>, grid <span class="string">on</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_03.png" alt=""> <p>With the help of the second moments of area we detected the rotation of the bat-signal every time.</p><p><b>Interpolation of a coarsely sampled circle</b></p><p>Going into some actual application examples, with numbers and stuff, let's define the sample points <tt>t</tt>, and the corresponding sample values <tt>x</tt> and <tt>y</tt>, describing a coarsely sampled circle with center at (0.2,-0.2).</p><pre class="codeinput">t = linspace(0,2*pi,9);
x = sin(t) + 0.2; y = cos(t) - 0.2;
</pre><p>Define a finer sampling, let's say, eight times finer, given by <tt>tq</tt>, and interpolate the closed curve at the query points. Finally plot the results.</p><pre class="codeinput">tq = 0:1/(8*(numel(t)-1)):1;
xyq = interpclosed(x,y,tq);
figure
plot(x,y,<span class="string">'o'</span>,xyq(1,:),xyq(2,:),<span class="string">':.'</span>);
axis <span class="string">equal</span>
title(<span class="string">'(Default) Spline Interpolation'</span>);
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_04.png" alt=""> <p>Interpolate again, but this time return the perimeter, area, centroid, and second moment of area of the fitted piece-wise polynomial. Then print to the console the results and the analytical values to compare.</p><pre class="codeinput">[len,area,c,I] = interpclosed(x,y);
fprintf([<span class="string">'Perimeter: %4.5f,	Area: %4.5f,\n'</span>,<span class="keyword">...</span>
    <span class="string">'Centroid: [%4.5f %4.5f],  Iz: %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'To be compared to\n'</span>,<span class="keyword">...</span>
    <span class="string">'2*pi:      %4.5f,	pi:   %4.5f,\n'</span>,<span class="keyword">...</span>
    <span class="string">'Centroid: [%4.5f %4.5f], pi/2: %4.5f\n'</span>],<span class="keyword">...</span>
    len,area,c,(I(1)-area*c(2)^2+I(2)-area*c(1)^2),<span class="keyword">...</span>
    2*pi,pi,[0.2,-0.2],pi/2)
</pre><pre class="codeoutput">Perimeter: 6.27938,	Area: 3.13776,
Centroid: [0.20000 -0.20000],  Iz: 1.56696
To be compared to
2*pi:      6.28319,	pi:   3.14159,
Centroid: [0.20000 -0.20000], pi/2: 1.57080
</pre><p><b>Interpolation of a heart-waming set of points</b></p><p>As shown in the Batman example, if a point is given twice at neighboring positons, the 1st derivatives of the piece-wise fit at this point will no longer be equal. For this example, take the dataset given in the documentation of the MATLAB&reg; function <tt>cscvn</tt>, fit the data with all the available methods and finally plot the results in a single figure using a small step.</p><pre class="codeinput">x = [0 .82 .92 0 0 -.92 -.82];
y = [.66 .9 0 -.83 -.83 0 .9];

tq = 0:0.01:1;

xyqS = interpclosed(x,y,tq);
xyqL = interpclosed(x,y,tq,<span class="string">'linear'</span>);
xyqP = interpclosed(x,y,tq,<span class="string">'pchip'</span>);

figure, plot(x,y,<span class="string">'o'</span>,xyqS(1,:),xyqS(2,:),xyqL(1,:),xyqL(2,:),xyqP(1,:),xyqP(2,:))
axis <span class="string">equal</span>, legend(<span class="string">'Points'</span>,<span class="string">'Spline'</span>,<span class="string">'Linear'</span>,<span class="string">'Pchip'</span>)
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_05.png" alt=""> <p>Please note that this time the given points do not describe a closed shape on their own. However, the function added the last point, corresponding with the first point of the set.</p><p>By giving as an input a logical variable <tt>print</tt>, an additional figure is plotted. This can be used to understand what is going on in the function under the hood. To showcase the plot, take the heart-shaped set of points, but this time remove the duplicate points. Then perform a linear fit, enable the <tt>print</tt> variable and return the piece-wise polynomial.</p><pre class="codeinput">x = [0 .82 .92 0 -.92 -.82];
y = [.66 .9 0 -.83 0 .9];

pp = interpclosed(x,y,<span class="string">'pp'</span>,<span class="string">'linear'</span>,true);
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_06.png" alt=""> <p>The parametric representation shows how the piece-wise fitting works. The same can be repeated with, for example, the spline fit, but this time, return the perimeter and the area.</p><pre class="codeinput">[len, area] = interpclosed(x,y,<span class="string">'spline'</span>,true);
fprintf(<span class="string">'Perimeter: %4.5f\nArea:      %4.5f\n'</span>,len,area);
</pre><pre class="codeoutput">Perimeter: 6.29776
Area:      2.61846
</pre><img vspace="5" hspace="5" src="interpclosed_documentation_07.png" alt=""> <p>Please note at this point how the spline fitting is way smoother than the linear one (obviously), not only in the cartestian but also in the parametric representation.</p><p>Let's now compute the derivatives of the piecewise functions at the start/end point for the three fitting options and see what happens. This is a key test to verify if the perpetual interpolation works correctly for the methods that allow it. To do this, we'll need the piece-wise polynomials, then we will derive them twice and finally we'll compute the derivatives at the desired points.</p><pre class="codeinput">ppS = interpclosed(x,y,<span class="string">'pp'</span>);
ppL = interpclosed(x,y,<span class="string">'pp'</span>,<span class="string">'linear'</span>);
ppP = interpclosed(x,y,<span class="string">'pp'</span>,<span class="string">'pchip'</span>);

dppS = fnder(ppS,1);  dppL = fnder(ppL,1);  dppP = fnder(ppP,1);
ddppS = fnder(ppS,2); ddppL = fnder(ppL,2); ddppP = fnder(ppP,2);

fprintf([<span class="string">'''linear'':\n'</span>,<span class="string">'1st derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'1st derivative at end (x,y):   %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at end (x,y):   %4.5f %4.5f\n'</span>],ppval(dppL,0),<span class="keyword">...</span>
    ppval(dppL,dppL.breaks(end)),ppval(ddppL,0),<span class="keyword">...</span>
    ppval(ddppL,ddppL.breaks(end)));

fprintf([<span class="string">'''pchip'':\n'</span>,<span class="string">'1st derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'1st derivative at end (x,y):   %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at end (x,y):   %4.5f %4.5f\n'</span>],ppval(dppP,0),<span class="keyword">...</span>
    ppval(dppP,dppP.breaks(end)),ppval(ddppP,0),<span class="keyword">...</span>
    ppval(ddppP,ddppP.breaks(end)));

fprintf([<span class="string">'''spline'':\n'</span>,<span class="string">'1st derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'1st derivative at end (x,y):   %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at start (x,y): %4.5f %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'2nd derivative at end (x,y):   %4.5f %4.5f\n'</span>],ppval(dppS,0),<span class="keyword">...</span>
    ppval(dppS,dppS.breaks(end)),ppval(ddppS,0),<span class="keyword">...</span>
    ppval(ddppS,ddppS.breaks(end)));
</pre><pre class="codeoutput">'linear':
1st derivative at start (x,y): 0.95974 0.28090
1st derivative at end (x,y):   0.95974 -0.28090
2nd derivative at start (x,y): 0.00000 0.00000
2nd derivative at end (x,y):   0.00000 0.00000
'pchip':
1st derivative at start (x,y): 0.95974 0.00000
1st derivative at end (x,y):   0.95974 -0.00000
2nd derivative at start (x,y): 1.77933 1.97260
2nd derivative at end (x,y):   -1.77933 1.97260
'spline':
1st derivative at start (x,y): 1.03558 0.00000
1st derivative at end (x,y):   1.03558 0.00000
2nd derivative at start (x,y): -0.00000 2.11655
2nd derivative at end (x,y):   0.00000 2.11655
</pre><p>As it can be seen in the documentation of <tt>interp1</tt>, the continuity of each of the methods here presented is consistent with the mathematical definitions at the start/end points of the closed curves, thus verifying that the curves are indeed perpetual .This means that the <tt>'linear'</tt> fit has no continuous derivatives (<img src="interpclosed_documentation_eq11964651111131359817.png" alt="$C^{0}$" style="width:16px;height:13px;">), the <tt>'pchip'</tt> fit has only one continuous derivative (<img src="interpclosed_documentation_eq04038067762979427218.png" alt="$C^{1}$" style="width:16px;height:13px;">) and the <tt>'spline'</tt> fit hast two continuous derivatives (<img src="interpclosed_documentation_eq17008715098456437789.png" alt="$C^{2}$" style="width:16px;height:13px;">).</p><p><b>Interpolation of sets of points describing a polygon</b></p><p>This kind of application can be solved only (one more time, obviously) by the linear interpolation. To illustrate the application, create a series of regular polygons inscribed in a circle of radius 1, return the perimeter and area of each polygon and compare it to the analytical values.</p><pre class="codeinput"><span class="keyword">for</span> ii = 4:13
    t = linspace(0,2*pi,ii);
    x = cos(t) + pi; y = sin(t)-2*pi;
    [len,area,c,I] = interpclosed(x,y,<span class="string">'linear'</span>);
    Ix = I(1)-area*c(2)^2;
    Iy = I(2)-area*c(1)^2;
    lenA = (ii-1)*2*sin(pi/(ii-1)); <span class="comment">% Analytical perimeter of inscribed polygon</span>
    areaA = 0.5*(ii-1)*sin(2*pi/(ii-1)); <span class="comment">% Analytical area of inscribed polygon</span>
    IxA = (ii-1)/48*(4*sin(2*pi/(ii-1))+sin(4*pi/(ii-1)));
    IyA = IxA;
    lendiff(ii-3) = len - lenA;
    areadiff(ii-3) = area - areaA;
    Ixdiff(ii-3) = Ix - IxA;
    Iydiff(ii-3) = Iy - IyA;
<span class="keyword">end</span>

fprintf([<span class="string">'Diff. analytical and computed perimeter:                   %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'Diff. analytical and computed area:                        %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'Diff. analytical and computed 2nd moment of area around x: %4.5f\n'</span>,<span class="keyword">...</span>
    <span class="string">'Diff. analytical and computed 2nd moment of area around y: %4.5f\n'</span>],<span class="keyword">...</span>
    sum(abs(lendiff)),sum(abs(areadiff)),sum(abs(Ixdiff)),sum(abs(Iydiff)));
</pre><pre class="codeoutput">Diff. analytical and computed perimeter:                   0.00000
Diff. analytical and computed area:                        0.00000
Diff. analytical and computed 2nd moment of area around x: 0.00000
Diff. analytical and computed 2nd moment of area around y: 0.00000
</pre><p>Please note that we compared the sum of the absolute value of the difference between the computed and analytical results. A result of zero means that throughout all polygons the perimeter, area, and second moments of area were correctly computed.</p><h2 id="21">See also</h2><p><tt>cscvn</tt>, <tt>pchip</tt>, <tt>mkpp</tt>, <tt>ppval</tt>, <tt>interparc</tt>, <tt>arclength</tt>, <tt>interp1</tt>, <tt>pdearcl</tt></p><h2 id="22">About</h2><p>Programmed by Santiago M. Benito at the Chair of Materials Technology of the Ruhr-Universit&auml;t Bochum. This programs contains snippets from the functions <tt>cscvn</tt>, <tt>arclength</tt> and <tt>interparc</tt>, thanks go to their respective authors.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |interpclosed| documentation
% The |interpclosed| function creates piecewise polynomial fits of 2D closed 
% curves given by a set of points. The function can be used to (i) return the fit 
% itself; (ii) interpolate values within the curve using an arc-length
% parametrization; or (iii) return the area, perimeter and centroid of the curve.
% |interpclosed| was inspired largely by the functions |cscvn|, |interparc|
% and |arclength|.
%
%% Syntax
% |xyq = interpclosed(x,y,tq)|
% 
% |[len,area] = interpclosed(x,y)|
%
% |[len,area,c] = interpclosed(x,y)|
%
% |[len,area,c,I] = interpclosed(x,y)|
% 
% |pp = interpclosed(x,y,'pp')|
% 
% |[xyq,len,area] = interpclosed(x,y,tq)|
%
% |[xyq,len,area,c] = interpclosed(x,y,tq)|
%
% |[xyq,len,area,c,I] = interpclosed(x,y,tq)|
% 
% |[___] = interpclosed(___,method)|
% 
% |[___] = interpclosed(___,print)|
%
%% Description
% |xyq = interpclosed(x,y,tq)| interpolates new data points |xyq| at 
% given positions defined by the array |tq|, along the closed curve defined 
% by the points specified by |x| and |y|. |xyq| is a 2-by-n array containing
% the x-y points corresponding to the query parameter positions defined in
% the n-by-1 array |tq|. The elements of |tq| can only take values between
% $[0,1]$, with 0 being the first point of the curve, 1 the last one and 0.5,
% for example, being in the middle of the length of the curve. The default
% method |'spline'| is used. 
% 
% |[len,area] = interpclosed(x,y)| returns the perimeter |len| and area  
% |area| of the interpolated curve.
%
% |[len,area,c] = interpclosed(x,y)| returns the perimeter, the area and the
% centroid |c| of the interpolated curve.
%
% |[len,area,c,I] = interpclosed(x,y)| returns the perimeter, the area, the
% centroid |c|, and second moments of area |I| of the interpolated curve.
% 
% |pp = interpclosed(x,y,'pp')| returns the piece-wise polynomial |pp|, which
% is a parametrization of the fit of |x| and |y| in the form $x(t)$ and $y(t)$.
% 
% |[xyq,len,area] = interpclosed(x,y,tq)| returns the new data points and 
% the perimeter and area.
%
% |[xyq,len,area,c] = interpclosed(x,y,tq)| returns the new data points and 
% the perimeter, area, and centroid.
%
% |[xyq,len,area,c,I] = interpclosed(x,y,tq)| returns the new data points  
% and the perimeter, area, centroid and second moments of area.
% 
% |[___] = interpclosed(_,method)| specifies the string |method|: |'linear'|, 
% |'spline'|, or |'pchip'|. The default method is |'spline'|.
% 
% |[___] = interpclosed(_,print)| additionaly prints some figures to show 
% the results. For printing 64 equally arc-length spaced points are used.
%
%% Examples
% *The Interpolated Batman*
%
% This first example only serves as a way to show off the power of the
% function, for more specific application examples, see the ones below.
%
% The so-called Batman function is a somewhat complex piecewise function.
% To construct it, 6 functions have to be defined between certain values of
% $x$ and $y$. You can find more information about the Batman function
% <https://de.mathworks.com/matlabcentral/answers/13131-batman-equation-in-matlab 
% here>
% and
% <https://de.mathworks.com/matlabcentral/fileexchange/33124-batman-equation-the-legend
% here>.
% 
% We, on the other hand, will create it as a piecewise polynomial function  
% that delivers very good results, out of a bunch of carefully selected points.
%
% First, we have to define the dataset and plot it to see what it looks like.
% Since the Batman function is symmetric around the y-axis, we just need
% the half of the actual points, then we can flip the arrays and append
% them conveniently. A minimum set of points was selected by choosing only
% the points defining vertices, and, when a curve was necessary, just one
% middle-point.
x = [0 0.5 0.5 0.75 0.75 1 1 2 3 3 7 4 4 3 2 2 1 0];

y = [2.25 2.25 2.25 3 3 1 1 0.863142928 2.717392773 2.717392773 ...
    0 -2.46195542 -2.46195542 -1.32235 -2.365485004 -2.365485004 ...
    -1.59137226 -3];

x = [x, -fliplr(x)]; y = [y,fliplr(y)];

figure, plot(x,y,'o'), axis equal
%%
% This doesn't look as terrifying as the dark knight, but we will fix this
% in a bit.
% Please note that some points are given twice, this is done to indicate 
% that the 1st derivative at those points does not have to be continuous.
% This idea was taken from the function |cscvn| and was extended to the 
% pchip fit here. For more information, go
% <https://de.mathworks.com/help/curvefit/cscvn.html
% here>.

%%
% Then fit and plot 300 equally spaced interpolation points, quite awesomely.
n = 300;
xyq = interpclosed(x,y,0:1/n:1);
figure, fill(xyq(1,:),xyq(2,:),'k'), hold on
plot(x,y,'yo','MarkerFaceColor',[1 .93 .22]), axis equal, grid on
legend('Batman','Original points')

%%
% The result is pretty legendary and was only created with 12 distinct points
% and knowledge about the continuity of the derivatives at those points.
% The bat-signal's orientation in 2D space is quite obvious to detect, this
% is down to the fact that its principal axes are easy to find. For
% instance, the signal has symmetry around the y-axis. This makes this
% particular shape useful to show the calculations that produce the
% geometric moments: area, centroid and second moment of area. The task
% will be to identify both a random rotation and translation of the shape.
% Let's make a figure with four subplots and assign an equal number of
% rotation and translations. Then compute the area, centroid, and second
% moment of area. This last piece of information will give us the
% information about the roration.

%%

% Define the rotations and translations
rot = 2*pi*rand(1,4);
dx = (-50+100*rand(1,4));
dy = (-50+100*rand(1,4));
% Create the figure
figure
for ii = 1:4
    % Compile the x and y vectors into a matrix
    xy = [x;y];
    % Rotate around (0,0)
    R = [cos(rot(ii)) -sin(rot(ii)); sin(rot(ii)) cos(rot(ii))];
    xy = R*xy;
    % Translate
    xn = xy(1,:)+dx(ii);
    yn = xy(2,:)+dy(ii);
    % Interpolate and find the area, centroid and second moments of area
    [xyq,~,area,c,I] = interpclosed(xn,yn,0:1/n:1);
    % Create the subplot
    subplot(2,2,ii), hold on
    % Show the bat-signal
    fill(xyq(1,:),xyq(2,:),'k'), hold on
    % Create the x- and y-axes before rotation
    xaxis = [-1,1;0,0]*5.25;
    yaxis = [0,0;-1,1]*7;
    % Use the second moments of area to find the rotation
    theta = -atan2(2*(I(3)-area*c(1)*c(2)),...
        ((I(1)-area*c(2)^2)-(I(2)-area*c(1)^2)))/2;
    % Construct the rotation matrix again
    R = [cos(theta) -sin(theta); sin(theta) cos(theta)];
    % Rotate the axes
    xaxis = R*xaxis;
    yaxis = R*yaxis;
    % Plot the axes
    plot(xaxis(1,:)+c(1),xaxis(2,:)+c(2),'r','LineWidth',1)
    plot(yaxis(1,:)+c(1),yaxis(2,:)+c(2),'rREPLACE_WITH_DASH_DASH')
    axis equal, grid on
end

%%
% With the help of the second moments of area we detected the rotation of
% the bat-signal every time.

%%
% *Interpolation of a coarsely sampled circle*
% 
% Going into some actual application examples, with numbers and stuff,
% let's define the sample points |t|, and the corresponding sample values
% |x| and |y|, describing a coarsely sampled circle with center at (0.2,-0.2). 
t = linspace(0,2*pi,9);
x = sin(t) + 0.2; y = cos(t) - 0.2;

%% 
% Define a finer sampling, let's say, eight times finer, given by |tq|, and
% interpolate the closed curve at the query points. Finally plot the results.
tq = 0:1/(8*(numel(t)-1)):1;
xyq = interpclosed(x,y,tq);
figure
plot(x,y,'o',xyq(1,:),xyq(2,:),':.');
axis equal
title('(Default) Spline Interpolation');

%%
% Interpolate again, but this time return the perimeter, area, centroid,
% and second moment of area of the fitted piece-wise polynomial. Then print
% to the console the results and the analytical values to compare.
[len,area,c,I] = interpclosed(x,y);
fprintf(['Perimeter: %4.5f,	Area: %4.5f,\n',...
    'Centroid: [%4.5f %4.5f],  Iz: %4.5f\n',...
    'To be compared to\n',...
    '2*pi:      %4.5f,	pi:   %4.5f,\n',...
    'Centroid: [%4.5f %4.5f], pi/2: %4.5f\n'],...
    len,area,c,(I(1)-area*c(2)^2+I(2)-area*c(1)^2),...
    2*pi,pi,[0.2,-0.2],pi/2)


%%
% *Interpolation of a heart-waming set of points*
%
% As shown in the Batman example, if a point is given twice at neighboring
% positons, the 1st derivatives of the piece-wise fit at this point will no
% longer be equal. For this example, take the dataset given in the documentation
% of the MATLAB(R) function |cscvn|, fit the data with all the available methods 
% and finally plot the results in a single figure using a small step.
x = [0 .82 .92 0 0 -.92 -.82];
y = [.66 .9 0 -.83 -.83 0 .9];

tq = 0:0.01:1;

xyqS = interpclosed(x,y,tq);
xyqL = interpclosed(x,y,tq,'linear');
xyqP = interpclosed(x,y,tq,'pchip');

figure, plot(x,y,'o',xyqS(1,:),xyqS(2,:),xyqL(1,:),xyqL(2,:),xyqP(1,:),xyqP(2,:))
axis equal, legend('Points','Spline','Linear','Pchip')
%%
% Please note that this time the given points do not describe a closed
% shape on their own. However, the function added the last point, 
% corresponding with the first point of the set.

%%
% By giving as an input a logical variable |print|, an additional figure is
% plotted. This can be used to understand what is going on in the function
% under the hood. To showcase the plot, take the heart-shaped set of points,
% but this time remove the duplicate points. Then perform a linear fit,
% enable the |print| variable and return the piece-wise polynomial.
x = [0 .82 .92 0 -.92 -.82];
y = [.66 .9 0 -.83 0 .9];

pp = interpclosed(x,y,'pp','linear',true);

%%
% The parametric representation shows how the piece-wise fitting works. The
% same can be repeated with, for example, the spline fit, but this time,
% return the perimeter and the area.
[len, area] = interpclosed(x,y,'spline',true);
fprintf('Perimeter: %4.5f\nArea:      %4.5f\n',len,area);

%%
% Please note at this point how the spline fitting is way smoother than
% the linear one (obviously), not only in the cartestian but also in the
% parametric representation.

%%
% Let's now compute the derivatives of the piecewise functions at the
% start/end point for the three fitting options and see what happens. This
% is a key test to verify if the perpetual interpolation works correctly
% for the methods that allow it. To do this, we'll need the piece-wise
% polynomials, then we will derive them twice and finally we'll compute the
% derivatives at the desired points.

ppS = interpclosed(x,y,'pp');
ppL = interpclosed(x,y,'pp','linear');
ppP = interpclosed(x,y,'pp','pchip');

dppS = fnder(ppS,1);  dppL = fnder(ppL,1);  dppP = fnder(ppP,1);
ddppS = fnder(ppS,2); ddppL = fnder(ppL,2); ddppP = fnder(ppP,2);

fprintf(['''linear'':\n','1st derivative at start (x,y): %4.5f %4.5f\n',...
    '1st derivative at end (x,y):   %4.5f %4.5f\n',...
    '2nd derivative at start (x,y): %4.5f %4.5f\n',...
    '2nd derivative at end (x,y):   %4.5f %4.5f\n'],ppval(dppL,0),...
    ppval(dppL,dppL.breaks(end)),ppval(ddppL,0),...
    ppval(ddppL,ddppL.breaks(end)));

fprintf(['''pchip'':\n','1st derivative at start (x,y): %4.5f %4.5f\n',...
    '1st derivative at end (x,y):   %4.5f %4.5f\n',...
    '2nd derivative at start (x,y): %4.5f %4.5f\n',...
    '2nd derivative at end (x,y):   %4.5f %4.5f\n'],ppval(dppP,0),...
    ppval(dppP,dppP.breaks(end)),ppval(ddppP,0),...
    ppval(ddppP,ddppP.breaks(end)));

fprintf(['''spline'':\n','1st derivative at start (x,y): %4.5f %4.5f\n',...
    '1st derivative at end (x,y):   %4.5f %4.5f\n',...
    '2nd derivative at start (x,y): %4.5f %4.5f\n',...
    '2nd derivative at end (x,y):   %4.5f %4.5f\n'],ppval(dppS,0),...
    ppval(dppS,dppS.breaks(end)),ppval(ddppS,0),...
    ppval(ddppS,ddppS.breaks(end)));

%%
% As it can be seen in the documentation of |interp1|, the continuity of
% each of the methods here presented is consistent with the mathematical
% definitions at the start/end points of the closed curves, thus verifying
% that the curves are indeed perpetual .This means that the |'linear'| fit 
% has no continuous derivatives ($C^{0}$), the |'pchip'| fit has only one 
% continuous derivative ($C^{1}$) and the |'spline'| fit hast two continuous 
% derivatives ($C^{2}$).

%%
% *Interpolation of sets of points describing a polygon*
%
% This kind of application can be solved only (one more time, obviously) by 
% the linear interpolation. To illustrate the application, create a series 
% of regular polygons inscribed in a circle of radius 1, return the perimeter
% and area of each polygon and compare it to the analytical values.

for ii = 4:13
    t = linspace(0,2*pi,ii);
    x = cos(t) + pi; y = sin(t)-2*pi;
    [len,area,c,I] = interpclosed(x,y,'linear');
    Ix = I(1)-area*c(2)^2;
    Iy = I(2)-area*c(1)^2;
    lenA = (ii-1)*2*sin(pi/(ii-1)); % Analytical perimeter of inscribed polygon
    areaA = 0.5*(ii-1)*sin(2*pi/(ii-1)); % Analytical area of inscribed polygon
    IxA = (ii-1)/48*(4*sin(2*pi/(ii-1))+sin(4*pi/(ii-1)));
    IyA = IxA;
    lendiff(ii-3) = len - lenA;
    areadiff(ii-3) = area - areaA;
    Ixdiff(ii-3) = Ix - IxA;
    Iydiff(ii-3) = Iy - IyA;
end

fprintf(['Diff. analytical and computed perimeter:                   %4.5f\n',...
    'Diff. analytical and computed area:                        %4.5f\n',...
    'Diff. analytical and computed 2nd moment of area around x: %4.5f\n',...
    'Diff. analytical and computed 2nd moment of area around y: %4.5f\n'],...
    sum(abs(lendiff)),sum(abs(areadiff)),sum(abs(Ixdiff)),sum(abs(Iydiff)));

%%
% Please note that we compared the sum of the absolute value of the
% difference between the computed and analytical results. A result of zero
% means that throughout all polygons the perimeter, area, and second moments
% of area were correctly computed.

%% See also
% |cscvn|, |pchip|, |mkpp|, |ppval|, |interparc|, |arclength|, |interp1|,
% |pdearcl|

%% About
% Programmed by Santiago M. Benito at the Chair of Materials Technology of
% the Ruhr-Universität Bochum.
% This programs contains snippets from the functions |cscvn|, |arclength| and
% |interparc|, thanks go to their respective authors. 
##### SOURCE END #####
--></body></html>